// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package export

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport(in *jlexer.Lexer, out *MemInfo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "SwapDevices":
			if in.IsNull() {
				in.Skip()
				out.SwapDevices = nil
			} else {
				in.Delim('[')
				if out.SwapDevices == nil {
					if !in.IsDelim(']') {
						out.SwapDevices = make([]*struct {
							Name      string `json:"name"`
							UsedBytes uint64 `json:"usedBytes"`
							FreeBytes uint64 `json:"freeBytes"`
						}, 0, 8)
					} else {
						out.SwapDevices = []*struct {
							Name      string `json:"name"`
							UsedBytes uint64 `json:"usedBytes"`
							FreeBytes uint64 `json:"freeBytes"`
						}{}
					}
				} else {
					out.SwapDevices = (out.SwapDevices)[:0]
				}
				for !in.IsDelim(']') {
					var v1 *struct {
						Name      string `json:"name"`
						UsedBytes uint64 `json:"usedBytes"`
						FreeBytes uint64 `json:"freeBytes"`
					}
					if in.IsNull() {
						in.Skip()
						v1 = nil
					} else {
						if v1 == nil {
							v1 = new(struct {
								Name      string `json:"name"`
								UsedBytes uint64 `json:"usedBytes"`
								FreeBytes uint64 `json:"freeBytes"`
							})
						}
						easyjsonC80ae7adDecode(in, v1)
					}
					out.SwapDevices = append(out.SwapDevices, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "SwapMemory":
			if in.IsNull() {
				in.Skip()
				out.SwapMemory = nil
			} else {
				if out.SwapMemory == nil {
					out.SwapMemory = new(struct {
						Total       uint64  `json:"total"`
						Used        uint64  `json:"used"`
						Free        uint64  `json:"free"`
						UsedPercent float64 `json:"usedPercent"`
						Sin         uint64  `json:"sin"`
						Sout        uint64  `json:"sout"`
						PgIn        uint64  `json:"pgIn"`
						PgOut       uint64  `json:"pgOut"`
						PgFault     uint64  `json:"pgFault"`
						PgMajFault  uint64  `json:"pgMajFault"`
					})
				}
				easyjsonC80ae7adDecode1(in, out.SwapMemory)
			}
		case "VirtualMemory":
			if in.IsNull() {
				in.Skip()
				out.VirtualMemory = nil
			} else {
				if out.VirtualMemory == nil {
					out.VirtualMemory = new(struct {
						Total          uint64  `json:"total"`
						Available      uint64  `json:"available"`
						Used           uint64  `json:"used"`
						UsedPercent    float64 `json:"usedPercent"`
						Free           uint64  `json:"free"`
						Active         uint64  `json:"active"`
						Inactive       uint64  `json:"inactive"`
						Wired          uint64  `json:"wired"`
						Laundry        uint64  `json:"laundry"`
						Buffers        uint64  `json:"buffers"`
						Cached         uint64  `json:"cached"`
						WriteBack      uint64  `json:"writeBack"`
						Dirty          uint64  `json:"dirty"`
						WriteBackTmp   uint64  `json:"writeBackTmp"`
						Shared         uint64  `json:"shared"`
						Slab           uint64  `json:"slab"`
						Sreclaimable   uint64  `json:"sreclaimable"`
						Sunreclaim     uint64  `json:"sunreclaim"`
						PageTables     uint64  `json:"pageTables"`
						SwapCached     uint64  `json:"swapCached"`
						CommitLimit    uint64  `json:"commitLimit"`
						CommittedAS    uint64  `json:"committedAS"`
						HighTotal      uint64  `json:"highTotal"`
						HighFree       uint64  `json:"highFree"`
						LowTotal       uint64  `json:"lowTotal"`
						LowFree        uint64  `json:"lowFree"`
						SwapTotal      uint64  `json:"swapTotal"`
						SwapFree       uint64  `json:"swapFree"`
						Mapped         uint64  `json:"mapped"`
						VmallocTotal   uint64  `json:"vmallocTotal"`
						VmallocUsed    uint64  `json:"vmallocUsed"`
						VmallocChunk   uint64  `json:"vmallocChunk"`
						HugePagesTotal uint64  `json:"hugePagesTotal"`
						HugePagesFree  uint64  `json:"hugePagesFree"`
						HugePagesRsvd  uint64  `json:"hugePagesRsvd"`
						HugePagesSurp  uint64  `json:"hugePagesSurp"`
						HugePageSize   uint64  `json:"hugePageSize"`
					})
				}
				easyjsonC80ae7adDecode2(in, out.VirtualMemory)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport(out *jwriter.Writer, in MemInfo) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"SwapDevices\":"
		out.RawString(prefix[1:])
		if in.SwapDevices == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.SwapDevices {
				if v2 > 0 {
					out.RawByte(',')
				}
				if v3 == nil {
					out.RawString("null")
				} else {
					easyjsonC80ae7adEncode(out, *v3)
				}
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"SwapMemory\":"
		out.RawString(prefix)
		if in.SwapMemory == nil {
			out.RawString("null")
		} else {
			easyjsonC80ae7adEncode1(out, *in.SwapMemory)
		}
	}
	{
		const prefix string = ",\"VirtualMemory\":"
		out.RawString(prefix)
		if in.VirtualMemory == nil {
			out.RawString("null")
		} else {
			easyjsonC80ae7adEncode2(out, *in.VirtualMemory)
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v MemInfo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v MemInfo) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *MemInfo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *MemInfo) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport(l, v)
}
func easyjsonC80ae7adDecode2(in *jlexer.Lexer, out *struct {
	Total          uint64  `json:"total"`
	Available      uint64  `json:"available"`
	Used           uint64  `json:"used"`
	UsedPercent    float64 `json:"usedPercent"`
	Free           uint64  `json:"free"`
	Active         uint64  `json:"active"`
	Inactive       uint64  `json:"inactive"`
	Wired          uint64  `json:"wired"`
	Laundry        uint64  `json:"laundry"`
	Buffers        uint64  `json:"buffers"`
	Cached         uint64  `json:"cached"`
	WriteBack      uint64  `json:"writeBack"`
	Dirty          uint64  `json:"dirty"`
	WriteBackTmp   uint64  `json:"writeBackTmp"`
	Shared         uint64  `json:"shared"`
	Slab           uint64  `json:"slab"`
	Sreclaimable   uint64  `json:"sreclaimable"`
	Sunreclaim     uint64  `json:"sunreclaim"`
	PageTables     uint64  `json:"pageTables"`
	SwapCached     uint64  `json:"swapCached"`
	CommitLimit    uint64  `json:"commitLimit"`
	CommittedAS    uint64  `json:"committedAS"`
	HighTotal      uint64  `json:"highTotal"`
	HighFree       uint64  `json:"highFree"`
	LowTotal       uint64  `json:"lowTotal"`
	LowFree        uint64  `json:"lowFree"`
	SwapTotal      uint64  `json:"swapTotal"`
	SwapFree       uint64  `json:"swapFree"`
	Mapped         uint64  `json:"mapped"`
	VmallocTotal   uint64  `json:"vmallocTotal"`
	VmallocUsed    uint64  `json:"vmallocUsed"`
	VmallocChunk   uint64  `json:"vmallocChunk"`
	HugePagesTotal uint64  `json:"hugePagesTotal"`
	HugePagesFree  uint64  `json:"hugePagesFree"`
	HugePagesRsvd  uint64  `json:"hugePagesRsvd"`
	HugePagesSurp  uint64  `json:"hugePagesSurp"`
	HugePageSize   uint64  `json:"hugePageSize"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "total":
			out.Total = uint64(in.Uint64())
		case "available":
			out.Available = uint64(in.Uint64())
		case "used":
			out.Used = uint64(in.Uint64())
		case "usedPercent":
			out.UsedPercent = float64(in.Float64())
		case "free":
			out.Free = uint64(in.Uint64())
		case "active":
			out.Active = uint64(in.Uint64())
		case "inactive":
			out.Inactive = uint64(in.Uint64())
		case "wired":
			out.Wired = uint64(in.Uint64())
		case "laundry":
			out.Laundry = uint64(in.Uint64())
		case "buffers":
			out.Buffers = uint64(in.Uint64())
		case "cached":
			out.Cached = uint64(in.Uint64())
		case "writeBack":
			out.WriteBack = uint64(in.Uint64())
		case "dirty":
			out.Dirty = uint64(in.Uint64())
		case "writeBackTmp":
			out.WriteBackTmp = uint64(in.Uint64())
		case "shared":
			out.Shared = uint64(in.Uint64())
		case "slab":
			out.Slab = uint64(in.Uint64())
		case "sreclaimable":
			out.Sreclaimable = uint64(in.Uint64())
		case "sunreclaim":
			out.Sunreclaim = uint64(in.Uint64())
		case "pageTables":
			out.PageTables = uint64(in.Uint64())
		case "swapCached":
			out.SwapCached = uint64(in.Uint64())
		case "commitLimit":
			out.CommitLimit = uint64(in.Uint64())
		case "committedAS":
			out.CommittedAS = uint64(in.Uint64())
		case "highTotal":
			out.HighTotal = uint64(in.Uint64())
		case "highFree":
			out.HighFree = uint64(in.Uint64())
		case "lowTotal":
			out.LowTotal = uint64(in.Uint64())
		case "lowFree":
			out.LowFree = uint64(in.Uint64())
		case "swapTotal":
			out.SwapTotal = uint64(in.Uint64())
		case "swapFree":
			out.SwapFree = uint64(in.Uint64())
		case "mapped":
			out.Mapped = uint64(in.Uint64())
		case "vmallocTotal":
			out.VmallocTotal = uint64(in.Uint64())
		case "vmallocUsed":
			out.VmallocUsed = uint64(in.Uint64())
		case "vmallocChunk":
			out.VmallocChunk = uint64(in.Uint64())
		case "hugePagesTotal":
			out.HugePagesTotal = uint64(in.Uint64())
		case "hugePagesFree":
			out.HugePagesFree = uint64(in.Uint64())
		case "hugePagesRsvd":
			out.HugePagesRsvd = uint64(in.Uint64())
		case "hugePagesSurp":
			out.HugePagesSurp = uint64(in.Uint64())
		case "hugePageSize":
			out.HugePageSize = uint64(in.Uint64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonC80ae7adEncode2(out *jwriter.Writer, in struct {
	Total          uint64  `json:"total"`
	Available      uint64  `json:"available"`
	Used           uint64  `json:"used"`
	UsedPercent    float64 `json:"usedPercent"`
	Free           uint64  `json:"free"`
	Active         uint64  `json:"active"`
	Inactive       uint64  `json:"inactive"`
	Wired          uint64  `json:"wired"`
	Laundry        uint64  `json:"laundry"`
	Buffers        uint64  `json:"buffers"`
	Cached         uint64  `json:"cached"`
	WriteBack      uint64  `json:"writeBack"`
	Dirty          uint64  `json:"dirty"`
	WriteBackTmp   uint64  `json:"writeBackTmp"`
	Shared         uint64  `json:"shared"`
	Slab           uint64  `json:"slab"`
	Sreclaimable   uint64  `json:"sreclaimable"`
	Sunreclaim     uint64  `json:"sunreclaim"`
	PageTables     uint64  `json:"pageTables"`
	SwapCached     uint64  `json:"swapCached"`
	CommitLimit    uint64  `json:"commitLimit"`
	CommittedAS    uint64  `json:"committedAS"`
	HighTotal      uint64  `json:"highTotal"`
	HighFree       uint64  `json:"highFree"`
	LowTotal       uint64  `json:"lowTotal"`
	LowFree        uint64  `json:"lowFree"`
	SwapTotal      uint64  `json:"swapTotal"`
	SwapFree       uint64  `json:"swapFree"`
	Mapped         uint64  `json:"mapped"`
	VmallocTotal   uint64  `json:"vmallocTotal"`
	VmallocUsed    uint64  `json:"vmallocUsed"`
	VmallocChunk   uint64  `json:"vmallocChunk"`
	HugePagesTotal uint64  `json:"hugePagesTotal"`
	HugePagesFree  uint64  `json:"hugePagesFree"`
	HugePagesRsvd  uint64  `json:"hugePagesRsvd"`
	HugePagesSurp  uint64  `json:"hugePagesSurp"`
	HugePageSize   uint64  `json:"hugePageSize"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"total\":"
		out.RawString(prefix[1:])
		out.Uint64(uint64(in.Total))
	}
	{
		const prefix string = ",\"available\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Available))
	}
	{
		const prefix string = ",\"used\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Used))
	}
	{
		const prefix string = ",\"usedPercent\":"
		out.RawString(prefix)
		out.Float64(float64(in.UsedPercent))
	}
	{
		const prefix string = ",\"free\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Free))
	}
	{
		const prefix string = ",\"active\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Active))
	}
	{
		const prefix string = ",\"inactive\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Inactive))
	}
	{
		const prefix string = ",\"wired\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Wired))
	}
	{
		const prefix string = ",\"laundry\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Laundry))
	}
	{
		const prefix string = ",\"buffers\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Buffers))
	}
	{
		const prefix string = ",\"cached\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Cached))
	}
	{
		const prefix string = ",\"writeBack\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.WriteBack))
	}
	{
		const prefix string = ",\"dirty\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Dirty))
	}
	{
		const prefix string = ",\"writeBackTmp\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.WriteBackTmp))
	}
	{
		const prefix string = ",\"shared\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Shared))
	}
	{
		const prefix string = ",\"slab\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Slab))
	}
	{
		const prefix string = ",\"sreclaimable\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Sreclaimable))
	}
	{
		const prefix string = ",\"sunreclaim\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Sunreclaim))
	}
	{
		const prefix string = ",\"pageTables\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PageTables))
	}
	{
		const prefix string = ",\"swapCached\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.SwapCached))
	}
	{
		const prefix string = ",\"commitLimit\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.CommitLimit))
	}
	{
		const prefix string = ",\"committedAS\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.CommittedAS))
	}
	{
		const prefix string = ",\"highTotal\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HighTotal))
	}
	{
		const prefix string = ",\"highFree\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HighFree))
	}
	{
		const prefix string = ",\"lowTotal\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.LowTotal))
	}
	{
		const prefix string = ",\"lowFree\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.LowFree))
	}
	{
		const prefix string = ",\"swapTotal\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.SwapTotal))
	}
	{
		const prefix string = ",\"swapFree\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.SwapFree))
	}
	{
		const prefix string = ",\"mapped\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Mapped))
	}
	{
		const prefix string = ",\"vmallocTotal\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.VmallocTotal))
	}
	{
		const prefix string = ",\"vmallocUsed\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.VmallocUsed))
	}
	{
		const prefix string = ",\"vmallocChunk\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.VmallocChunk))
	}
	{
		const prefix string = ",\"hugePagesTotal\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HugePagesTotal))
	}
	{
		const prefix string = ",\"hugePagesFree\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HugePagesFree))
	}
	{
		const prefix string = ",\"hugePagesRsvd\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HugePagesRsvd))
	}
	{
		const prefix string = ",\"hugePagesSurp\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HugePagesSurp))
	}
	{
		const prefix string = ",\"hugePageSize\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.HugePageSize))
	}
	out.RawByte('}')
}
func easyjsonC80ae7adDecode1(in *jlexer.Lexer, out *struct {
	Total       uint64  `json:"total"`
	Used        uint64  `json:"used"`
	Free        uint64  `json:"free"`
	UsedPercent float64 `json:"usedPercent"`
	Sin         uint64  `json:"sin"`
	Sout        uint64  `json:"sout"`
	PgIn        uint64  `json:"pgIn"`
	PgOut       uint64  `json:"pgOut"`
	PgFault     uint64  `json:"pgFault"`
	PgMajFault  uint64  `json:"pgMajFault"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "total":
			out.Total = uint64(in.Uint64())
		case "used":
			out.Used = uint64(in.Uint64())
		case "free":
			out.Free = uint64(in.Uint64())
		case "usedPercent":
			out.UsedPercent = float64(in.Float64())
		case "sin":
			out.Sin = uint64(in.Uint64())
		case "sout":
			out.Sout = uint64(in.Uint64())
		case "pgIn":
			out.PgIn = uint64(in.Uint64())
		case "pgOut":
			out.PgOut = uint64(in.Uint64())
		case "pgFault":
			out.PgFault = uint64(in.Uint64())
		case "pgMajFault":
			out.PgMajFault = uint64(in.Uint64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonC80ae7adEncode1(out *jwriter.Writer, in struct {
	Total       uint64  `json:"total"`
	Used        uint64  `json:"used"`
	Free        uint64  `json:"free"`
	UsedPercent float64 `json:"usedPercent"`
	Sin         uint64  `json:"sin"`
	Sout        uint64  `json:"sout"`
	PgIn        uint64  `json:"pgIn"`
	PgOut       uint64  `json:"pgOut"`
	PgFault     uint64  `json:"pgFault"`
	PgMajFault  uint64  `json:"pgMajFault"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"total\":"
		out.RawString(prefix[1:])
		out.Uint64(uint64(in.Total))
	}
	{
		const prefix string = ",\"used\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Used))
	}
	{
		const prefix string = ",\"free\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Free))
	}
	{
		const prefix string = ",\"usedPercent\":"
		out.RawString(prefix)
		out.Float64(float64(in.UsedPercent))
	}
	{
		const prefix string = ",\"sin\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Sin))
	}
	{
		const prefix string = ",\"sout\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Sout))
	}
	{
		const prefix string = ",\"pgIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PgIn))
	}
	{
		const prefix string = ",\"pgOut\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PgOut))
	}
	{
		const prefix string = ",\"pgFault\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PgFault))
	}
	{
		const prefix string = ",\"pgMajFault\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PgMajFault))
	}
	out.RawByte('}')
}
func easyjsonC80ae7adDecode(in *jlexer.Lexer, out *struct {
	Name      string `json:"name"`
	UsedBytes uint64 `json:"usedBytes"`
	FreeBytes uint64 `json:"freeBytes"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "name":
			out.Name = string(in.String())
		case "usedBytes":
			out.UsedBytes = uint64(in.Uint64())
		case "freeBytes":
			out.FreeBytes = uint64(in.Uint64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonC80ae7adEncode(out *jwriter.Writer, in struct {
	Name      string `json:"name"`
	UsedBytes uint64 `json:"usedBytes"`
	FreeBytes uint64 `json:"freeBytes"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"name\":"
		out.RawString(prefix[1:])
		out.String(string(in.Name))
	}
	{
		const prefix string = ",\"usedBytes\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.UsedBytes))
	}
	{
		const prefix string = ",\"freeBytes\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.FreeBytes))
	}
	out.RawByte('}')
}
func easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport1(in *jlexer.Lexer, out *CpuInfo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "CPU":
			if in.IsNull() {
				in.Skip()
				out.CPU = nil
			} else {
				in.Delim('[')
				if out.CPU == nil {
					if !in.IsDelim(']') {
						out.CPU = make([]CPUStat, 0, 0)
					} else {
						out.CPU = []CPUStat{}
					}
				} else {
					out.CPU = (out.CPU)[:0]
				}
				for !in.IsDelim(']') {
					var v4 CPUStat
					easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport2(in, &v4)
					out.CPU = append(out.CPU, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport1(out *jwriter.Writer, in CpuInfo) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"CPU\":"
		out.RawString(prefix[1:])
		if in.CPU == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v5, v6 := range in.CPU {
				if v5 > 0 {
					out.RawByte(',')
				}
				easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport2(out, v6)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v CpuInfo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v CpuInfo) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *CpuInfo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *CpuInfo) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport1(l, v)
}
func easyjsonC80ae7adDecodeYuiProtoLibrarySystemInfoExport2(in *jlexer.Lexer, out *CPUStat) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "cpu":
			out.CPU = int32(in.Int32())
		case "vendorId":
			out.VendorID = string(in.String())
		case "family":
			out.Family = string(in.String())
		case "model":
			out.Model = string(in.String())
		case "stepping":
			out.Stepping = int32(in.Int32())
		case "physicalId":
			out.PhysicalID = string(in.String())
		case "coreId":
			out.CoreID = string(in.String())
		case "cores":
			out.Cores = int32(in.Int32())
		case "modelName":
			out.ModelName = string(in.String())
		case "mhz":
			out.Mhz = float64(in.Float64())
		case "cacheSize":
			out.CacheSize = int32(in.Int32())
		case "flags":
			if in.IsNull() {
				in.Skip()
				out.Flags = nil
			} else {
				in.Delim('[')
				if out.Flags == nil {
					if !in.IsDelim(']') {
						out.Flags = make([]string, 0, 4)
					} else {
						out.Flags = []string{}
					}
				} else {
					out.Flags = (out.Flags)[:0]
				}
				for !in.IsDelim(']') {
					var v7 string
					v7 = string(in.String())
					out.Flags = append(out.Flags, v7)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "microcode":
			out.Microcode = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonC80ae7adEncodeYuiProtoLibrarySystemInfoExport2(out *jwriter.Writer, in CPUStat) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"cpu\":"
		out.RawString(prefix[1:])
		out.Int32(int32(in.CPU))
	}
	{
		const prefix string = ",\"vendorId\":"
		out.RawString(prefix)
		out.String(string(in.VendorID))
	}
	{
		const prefix string = ",\"family\":"
		out.RawString(prefix)
		out.String(string(in.Family))
	}
	{
		const prefix string = ",\"model\":"
		out.RawString(prefix)
		out.String(string(in.Model))
	}
	{
		const prefix string = ",\"stepping\":"
		out.RawString(prefix)
		out.Int32(int32(in.Stepping))
	}
	{
		const prefix string = ",\"physicalId\":"
		out.RawString(prefix)
		out.String(string(in.PhysicalID))
	}
	{
		const prefix string = ",\"coreId\":"
		out.RawString(prefix)
		out.String(string(in.CoreID))
	}
	{
		const prefix string = ",\"cores\":"
		out.RawString(prefix)
		out.Int32(int32(in.Cores))
	}
	{
		const prefix string = ",\"modelName\":"
		out.RawString(prefix)
		out.String(string(in.ModelName))
	}
	{
		const prefix string = ",\"mhz\":"
		out.RawString(prefix)
		out.Float64(float64(in.Mhz))
	}
	{
		const prefix string = ",\"cacheSize\":"
		out.RawString(prefix)
		out.Int32(int32(in.CacheSize))
	}
	{
		const prefix string = ",\"flags\":"
		out.RawString(prefix)
		if in.Flags == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Flags {
				if v8 > 0 {
					out.RawByte(',')
				}
				out.String(string(v9))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"microcode\":"
		out.RawString(prefix)
		out.String(string(in.Microcode))
	}
	out.RawByte('}')
}
